
<HTML>

<HEAD> <TITLE> CS 471  - PROJECT 1 - FAQ  </TITLE> </HEAD>

<BODY BGCOLOR=#FFFFFF TEXT=#000000 LINK=#0000CC>

<H3> <FONT COLOR=BLUE> CS 471: PROJECT 1  <BR>
Frequently Asked Questions </H3> </FONT> 

<BR>




<UL>

<LI> <B> Should we assume any context switch overhead? </B> <BR>
No. As can be seen from the sample output file, you can assume that the context switch occurs 
instantaneously. 
</LI>


<LI> <B> My program works with the input file you provided for MLF Queue.
Am I done? </B> <BR>
The sample input and output files are provided for your convenience, to illustrate 
the expected format of the output.
We will use other test files while grading the project.
So make sure that your program correctly implements all the
requirements of the project specification.
</LI>



<LI>
<B>I checked the trace file you provided for the MLF Queue.
Should the output of our program be identical to yours line by line? </B>
<BR>
Not necessarily. However, ALL information 
regarding important events (as indicated on page
3 of the hand-out, and provided in the
example output file) should also be in your output file;
including timing of events, status/contents of ready and device queues,
task dispatch/preemption times, demotion times, etc.
For example, at some points during the execution,
the CPU and an I/O device may become
<I> simultaneously </I> available for two different processes,
and you are free to print the information about
either the CPU dispatch or I/O start operations first. </LI>



<LI> <B> 
How do we compute the waiting time and turnaround time for a process?
</B> <BR> 
As we discussed in class, the waiting time of a process is the total 
amount of time it spends in the <I>ready queue</I>. 
Since the project involves three levels of ready queues, any amount of time 
a process spends in any of these three queues will be counted as part of  its 
waiting time. 
The turnaround time 
of a process is the difference between its completion time and arrival time.
</LI> 



<LI> <B> 
The hand-out does not specify any "promotion" rule, regarding when 
a process is moved from a lower-level ready queue to a higher-level ready queue?   
</B> <BR> 
That is correct. In this simple system, processes never "promote" but only demote. 
The fact that the processes start the new CPU burst (when I/O completes)
at Q1 does not mean that they get "promoted" (Promotion occurs when 
a process moves from a lower-level ready queue to a higher-level ready queue during 
a given CPU burst; this never 
happens in this system). 
Each new CPU burst of a given
process P can be seen as a "new life" of P in this project.
</LI> 


<LI> <B> 
Looking at the output file for the Round-Robin policy (with single queue), 
I can see 
that Process 2 is running from time=230 to time=350. Yet, it appears 
that it is preempted at time=330, only to be re-dispatched again. 
Can you explain? 
</B> <BR> 
Remember that in that example the time quantum is 100. Therefore, P2 
is preempted at time=330 because the "timer expires". But the scheduler 
re-selects the same process at that time, because there is no 
other ready process. 
</LI> 

<LI> <B> 
Should we submit the executable file as well? 
</B>
<BR> 
No. We only need the source files and the information 
about how to compile and run your program (see the next 
question).
</LI>

<LI> <B>  How are you going to invoke our program with your 
specific input files? That is, what will be the syntax you will be following on the command line? 
 </B>
<BR>
It is your responsibility to specify in the "write-up" 
all the necessary  
operational details on compiling and running your program. 
You should tell us in advance what we should enter if, for 
example, we want to run your program with an input file 
named "test1.dat". Similarly, you should tell us 
the name of the output file you generate so that we can look for it.
However, do not hard-code the names of the input or output files in
your source files; the user shouldn't have to edit your source file
for every new input file.

Also indicate the specific remotely accessible 
VS&E machine on which your program compiles and runs 
(mason or zeus), so that we 
can connect there and test your program.  See the handout for the README file contents  that we expect from you.
</LI>



<LI> <B> Will we be graded on the efficiency of our program?
 </B>
<BR>
The correctness and adherence to the specification are the
most important issues. The efficiency is highly desirable but
will not be an item in the grading. 
</LI>




<LI> <B> Will the process ID ever be a number < 1 or > 10?
 </B>
<BR>
No, it will be a number between 1 and 10.
</LI>



<LI>
<B> Will the input file format be exactly like the
examples
with character strings before the colons or will it just be a list
of
numbers? </B>
<BR> The input file will contain specific character strings 
you see in the examples and  the specification. That is, your 
program should be able to process the strings, "Process ID", "Arrival Time" 
etc. Your program can accept the same string  regardless of whether it is entered in lower-case or upper-case letters -- e.g. "PROCESS ID", "Process Id" or "process id" may all be acceptable.  
</LI>


<LI><B> What should we include in the project write-up? </B><BR>
You should present a high-level view of your design. We should 
be able to see the main components of your simulator, 
and their interaction. You do not need to describe each and 
every function in detail; but we should be able to see 
how and in what order you make CPU and I/O scheduling decisions 
as the "clock" advances.  
In addition, explain the data structures you used for the MLF Queues and Device Queues in detail. 
If you organize your report well, 
a write-up of 3-4 pages should be o.k., assuming that it provides 
this info. 
</LI>


<LI> <B> Will we get partial credit if we implement only round-robin policy
with one queue and one quantum? 
<BR> </B> 
You can get some partial credit, but it will not be significant. 
But once you implement the single-level system, you will see that 
the extension to three-level system is not very difficult. 
</LI> 


<LI>
<B> What should the program do if the input file violates 
the format given in the specification? </B>
<BR>
It should display an error message and exit. However, recall 
that you program should be able to skip any number of blank lines.
</LI>

<LI>
<B> 
Can we make certain assumptions about the order in which processes appear in the input file? For example, can we assume that processes appear starting with Process 1 and in the order of 2, 3... </B>
<BR>
Here are the simplifications that you are allowed to make: In the input file, 
Process <i> j </i> will appear before Process <i> j+1 </i>. The first process to appear will be Process 1. Also you can assume that the arrival time of Process <i> j+1 </i> will not be earlier than that of Process <i>j</i>.  

Also the system will have <i>k</i> I/O devices numbered from 1 to <i>k</i> (where <i>k</i> is no greater than 5). Note, however, that a process doesn't necessarily have to use the I/O device <i> j </i> before the I/O device <i> j+1 </i>.   
</LI>



<LI>
<B> Will the sequence of CPU and I/O bursts appear always as pairs?
For example, can we have a process with just one CPU burst without
an I/O burst?  </B>
<BR>
They will always appear as pairs. If there is one CPU burst, there 
will be also a corresponding I/O burst.
</LI>

<LI>
<B> Is there a time quantum for I/O operations?
</B>
<BR>
No. I/O requests for a specific device are served in non-preemptive manner, following the FCFS rule (see the hand-out). 

<LI>
<B>
For Q3, we are using the SRTF policy. When computing the "remaining
time" of the processes, should we consider the remaining time in the
*current* CPU bursts of the processes, or the total remaining time in
all the subsequent CPU bursts of the individual processes?  
</B>
<BR>
As we discussed in class, for processes with multiple CPU and I/O
bursts, the scheduling algorithm will always consider the current CPU
bursts when making decisions. Consequently, in Q3, SRTF will need to
consider the remaining time in the current CPU bursts of the
processes. 

<LI>
<B>
Suppose at a certain time, Q1 is empty. P2 is executing in Q2 with
time quantum 50, and P3 is waiting its turn in Q2.
After executing P2 for 30 time units, a new process P4 arrives to Q1.
P4 will obviously preempt P2. Note that P2 has still 20 time units
left in its time quantum. If P4 completes its CPU burst quickly, who
will execute next? And for how long? </B>
<BR>
If a process is preempted before using its entire time quantum in Q2,
it will use the remaining part of its time quantum when it resumes
execution. This is mentioned in the handout.
In your example, P2 can execute for 20 more time units when
P1 departs. After that P3 can start to execute.


<LI>
<B>
Can we use arrays as part of a struct? 
</B>
<BR>
As the handout states, in this project, arrays can only be used for string manipulation
and file reading/writing purposes. All scheduling related constructs
should be designed without arrays. 
<BR>




<LI> <B> At the beginning of each "clock loop", I first check 
the processes that may be arriving or starting a new CPU burst 
at that exact time point, I move them to Q1, and only then I proceed with other 
decisions (such as CPU dispatch and/or I/O device management). 
Is this o.k.? </B>
<BR> 
Yes, it is fine. </LI>
<LI> <B> 
Can we form a group of three? </B> <BR> 
Sorry. As indicated in the hand-out, you can work with groups 
of two.
</LI> 
<LI> <B> I want to work with a partner but I am unable to find 
one. Can you help me? </B> <BR> 
You can send me e-mail indicating your name and your availability constraints.
 If I receive a similar request 
from another student, I can send e-mail to both
of you and you can form a group. However, note that this will 
be a "random match" and there is no guarantee that your group 
will deliver a good project. It is always better if you can 
identify your own partner. 


</UL>


</HTML>





















